<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lisis de la Capa de Datos (/data) - App AjiColor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 40px;
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 30px;
            border-bottom: 4px solid #764ba2;
            padding-bottom: 15px;
            text-align: center;
        }

        h2 {
            color: #764ba2;
            font-size: 2em;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-left: 10px;
            border-left: 5px solid #667eea;
        }

        h3 {
            color: #5a67d8;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
            background: linear-gradient(to right, #f0f4ff, transparent);
            padding: 10px 15px;
            border-radius: 5px;
        }

        h4 {
            color: #4c51bf;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
            color: #444;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
            color: #555;
        }

        code {
            background: #f7fafc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e53e3e;
            font-size: 0.9em;
        }

        pre {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #667eea;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        pre code {
            background: transparent;
            color: #e2e8f0;
            padding: 0;
            font-size: 0.95em;
        }

        .highlight {
            background: linear-gradient(120deg, #ffd60a 0%, #ffd60a 100%);
            background-repeat: no-repeat;
            background-size: 100% 30%;
            background-position: 0 90%;
            padding: 2px 0;
        }

        .box {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .box-info {
            background: #ebf8ff;
            border-color: #3182ce;
        }

        .box-warning {
            background: #fffaf0;
            border-color: #ed8936;
        }

        .box-success {
            background: #f0fff4;
            border-color: #38a169;
        }

        .diagram {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .flow-step {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .arrow {
            display: inline-block;
            color: #667eea;
            font-size: 2em;
            margin: 0 10px;
            font-weight: bold;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: bold;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        tr:hover {
            background: #f7fafc;
        }

        .folder-tree {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            line-height: 1.8;
        }

        .folder {
            color: #ffd60a;
            font-weight: bold;
        }

        .file {
            color: #68d391;
        }

        .annotation {
            color: #9f7aea;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì¶ An√°lisis de la Capa de Datos (/data)</h1>

        <h2>üéØ Prop√≥sito de la Capa de Datos en Arquitectura MVVM</h2>
        <p>
            La carpeta <code>/data</code> representa la <span class="highlight">capa de datos</span> en la arquitectura MVVM (Model-View-ViewModel)
            de nuestra aplicaci√≥n Android. Esta capa act√∫a como la <strong>"Single Source of Truth" (√önica Fuente de Verdad)</strong>, centralizando
            toda la l√≥gica relacionada con la obtenci√≥n, almacenamiento y gesti√≥n de datos.
        </p>

        <div class="box box-info">
            <h4>üîë Principios Fundamentales</h4>
            <ul>
                <li><strong>Single Source of Truth:</strong> Un √∫nico lugar donde los datos son definitivos y confiables</li>
                <li><strong>Separaci√≥n de Responsabilidades:</strong> Divide fuentes de datos locales (Room/SQLite) y remotas (Retrofit/API)</li>
                <li><strong>Abstracci√≥n de Datos:</strong> El ViewModel no conoce los detalles de implementaci√≥n de c√≥mo se obtienen los datos</li>
                <li><strong>Gesti√≥n de Estado:</strong> Maneja estados de carga, √©xito y error de operaciones as√≠ncronas</li>
            </ul>
        </div>

        <h3>üß© Componentes Principales</h3>
        <p>La capa de datos en App AjiColor se estructura en los siguientes componentes:</p>
        <ul>
            <li><strong>Repositorios:</strong> Coordinan m√∫ltiples fuentes de datos y exponen una API limpia al ViewModel</li>
            <li><strong>Fuentes de Datos Locales:</strong> Room Database para persistencia en SQLite</li>
            <li><strong>Fuentes de Datos Remotas:</strong> (Preparado para) APIs REST con Retrofit</li>
            <li><strong>Modelos de Datos:</strong> Entidades de Room, DTOs para API, y modelos de dominio</li>
            <li><strong>Gesti√≥n de Sesi√≥n:</strong> SharedPreferences y DataStore para preferencias de usuario</li>
        </ul>

        <h2>üìÇ Estructura Completa de la Carpeta /data</h2>
        <div class="folder-tree">
üìÅ data/
‚îú‚îÄ‚îÄ üìÑ <span class="file">CarritoModels.kt</span>         <span class="annotation">// Modelos del carrito de compras</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">CatalogoProductos.kt</span>     <span class="annotation">// Cat√°logo de productos disponibles</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">CategoriaProducto.kt</span>     <span class="annotation">// Enumeraci√≥n de categor√≠as</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">ColoresDisponibles.kt</span>    <span class="annotation">// Lista de colores disponibles</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">ColorInfo.kt</span>             <span class="annotation">// Informaci√≥n de color (nombre, hex, Compose Color)</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">Notificacion.kt</span>          <span class="annotation">// Modelo de notificaciones</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">PedidoCompleto.kt</span>        <span class="annotation">// Modelo de pedido completo</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">Producto.kt</span>              <span class="annotation">// Modelo de producto de dominio</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">Talla.kt</span>                 <span class="annotation">// Enumeraci√≥n de tallas</span>
‚îú‚îÄ‚îÄ üìÑ <span class="file">TipoProducto.kt</span>          <span class="annotation">// Tipos de producto (Adulto/Infantil)</span>
‚îÇ
‚îú‚îÄ‚îÄ üìÅ <span class="folder">local/</span>                         <span class="annotation">// Fuentes de datos locales</span>
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ <span class="folder">database/</span>
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ <span class="file">AppDatabase.kt</span>   <span class="annotation">// Base de datos Room (SQLite)</span>
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ <span class="folder">user/</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ <span class="file">UserDao.kt</span>       <span class="annotation">// Data Access Object para usuarios</span>
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ <span class="file">UserEntity.kt</span>    <span class="annotation">// Entidad de usuario (tabla users)</span>
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ <span class="folder">pedido/</span>
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ <span class="file">PedidoDao.kt</span>     <span class="annotation">// DAO para pedidos</span>
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ <span class="file">PedidoEntity.kt</span>  <span class="annotation">// Entidades de pedidos e items</span>
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ <span class="folder">storage/</span>
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ <span class="file">UserPreferences.kt</span> <span class="annotation">// DataStore para preferencias</span>
‚îÇ
‚îú‚îÄ‚îÄ üìÅ <span class="folder">models/</span>                        <span class="annotation">// Modelos adicionales</span>
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ <span class="file">ProductoModels.kt</span>    <span class="annotation">// Modelos relacionados con productos</span>
‚îÇ
‚îú‚îÄ‚îÄ üìÅ <span class="folder">repository/</span>                    <span class="annotation">// Repositorios (patr√≥n Repository)</span>
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ <span class="file">UserRepository.kt</span>    <span class="annotation">// Repositorio de usuarios</span>
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ <span class="file">PedidoRepository.kt</span>  <span class="annotation">// Repositorio de pedidos</span>
‚îÇ
‚îî‚îÄ‚îÄ üìÅ <span class="folder">session/</span>                       <span class="annotation">// Gesti√≥n de sesi√≥n</span>
    ‚îî‚îÄ‚îÄ üìÑ <span class="file">SessionManager.kt</span>    <span class="annotation">// Manejo de sesi√≥n con SharedPreferences</span>
        </div>

        <h2>üîç An√°lisis Detallado por Componentes</h2>

        <h3>1Ô∏è‚É£ Local Database - AppDatabase.kt</h3>
        <p>
            <code>AppDatabase</code> es la clase principal de Room que representa la base de datos SQLite de la aplicaci√≥n.
            Room es una biblioteca de abstracci√≥n sobre SQLite que proporciona una capa robusta de acceso a datos con
            validaci√≥n en tiempo de compilaci√≥n.
        </p>

        <h4>üìã Caracter√≠sticas Clave:</h4>
        <ul>
            <li><strong>Patr√≥n Singleton:</strong> Una √∫nica instancia de la base de datos en toda la aplicaci√≥n</li>
            <li><strong>Entidades Registradas:</strong> UserEntity, PedidoEntity, PedidoItemEntity</li>
            <li><strong>Versi√≥n de Esquema:</strong> Version 2 (con migraci√≥n destructiva para desarrollo)</li>
            <li><strong>Precarga de Datos:</strong> Callback <code>onCreate()</code> que inserta usuarios de prueba</li>
        </ul>

        <div class="box box-success">
            <h4>üí° C√≥digo Clave: AppDatabase.kt</h4>
            <pre><code>@Database(
    entities = [UserEntity::class, PedidoEntity::class, PedidoItemEntity::class],
    version = 2,
    exportSchema = true
)
abstract class AppDatabase : RoomDatabase() {

    // DAOs expuestos
    abstract fun userDao(): UserDao
    abstract fun pedidoDao(): PedidoDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_ajicolor.db"
                )
                .addCallback(object : RoomDatabase.Callback() {
                    override fun onCreate(db: SupportSQLiteDatabase) {
                        super.onCreate(db)
                        // Precarga de datos iniciales
                        CoroutineScope(Dispatchers.IO).launch {
                            val dao = getInstance(context).userDao()
                            if (dao.countUsers() == 0) {
                                // Insertar usuarios de prueba
                                dao.insert(UserEntity(...))
                            }
                        }
                    }
                })
                .fallbackToDestructiveMigration()
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}</code></pre>
        </div>

        <h4>üîß Explicaci√≥n T√©cnica:</h4>
        <ul>
            <li><strong>@Database:</strong> Anotaci√≥n que marca la clase como una base de datos Room</li>
            <li><strong>@Volatile:</strong> Asegura que los cambios en INSTANCE sean visibles para todos los hilos</li>
            <li><strong>synchronized(this):</strong> Bloque sincronizado para evitar m√∫ltiples instancias en hilos concurrentes</li>
            <li><strong>applicationContext:</strong> Usa el contexto de aplicaci√≥n para evitar memory leaks</li>
            <li><strong>fallbackToDestructiveMigration():</strong> En desarrollo, elimina y recrea la BD si cambia la versi√≥n</li>
            <li><strong>CoroutineScope(Dispatchers.IO):</strong> Ejecuta operaciones de BD en hilo de entrada/salida</li>
        </ul>

        <h3>2Ô∏è‚É£ Data Access Objects (DAOs)</h3>
        <p>
            Los DAOs son interfaces que definen los m√©todos de acceso a la base de datos. Room genera autom√°ticamente
            la implementaci√≥n de estos m√©todos en tiempo de compilaci√≥n.
        </p>

        <h4>üìÑ UserDao.kt - DAO de Usuarios</h4>
        <div class="box box-info">
            <pre><code>@Dao
interface UserDao {
    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insert(user: UserEntity): Long

    @Query("SELECT * FROM users WHERE correo = :email LIMIT 1")
    suspend fun getUserByEmail(email: String): UserEntity?

    @Query("SELECT * FROM users WHERE id = :userId LIMIT 1")
    suspend fun getUserById(userId: Long): UserEntity?

    @Update
    suspend fun update(user: UserEntity): Int

    @Query("DELETE FROM users")
    suspend fun deleteAll()

    @Query("SELECT COUNT(*) FROM users")
    suspend fun countUsers(): Int
}</code></pre>
        </div>

        <h4>üîç Anotaciones de Room:</h4>
        <table>
            <thead>
                <tr>
                    <th>Anotaci√≥n</th>
                    <th>Descripci√≥n</th>
                    <th>Uso</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>@Dao</code></td>
                    <td>Marca una interfaz como Data Access Object</td>
                    <td>Room genera la implementaci√≥n autom√°ticamente</td>
                </tr>
                <tr>
                    <td><code>@Insert</code></td>
                    <td>Define un m√©todo de inserci√≥n</td>
                    <td>Retorna el ID generado (Long)</td>
                </tr>
                <tr>
                    <td><code>@Query</code></td>
                    <td>Define una consulta SQL personalizada</td>
                    <td>Validada en tiempo de compilaci√≥n</td>
                </tr>
                <tr>
                    <td><code>@Update</code></td>
                    <td>Actualiza una entidad existente</td>
                    <td>Retorna el n√∫mero de filas afectadas</td>
                </tr>
                <tr>
                    <td><code>@Delete</code></td>
                    <td>Elimina una entidad</td>
                    <td>Usa la clave primaria para identificar</td>
                </tr>
                <tr>
                    <td><code>suspend</code></td>
                    <td>Funci√≥n de corrutina (as√≠ncrona)</td>
                    <td>Permite operaciones sin bloquear el hilo principal</td>
                </tr>
            </tbody>
        </table>

        <h4>‚ö° Estrategias de Conflicto:</h4>
        <ul>
            <li><strong>ABORT:</strong> Lanza una excepci√≥n si hay conflicto (usado para evitar duplicados)</li>
            <li><strong>REPLACE:</strong> Reemplaza la fila existente con los nuevos datos</li>
            <li><strong>IGNORE:</strong> Ignora el nuevo registro si ya existe</li>
            <li><strong>ROLLBACK:</strong> Deshace la transacci√≥n completa</li>
        </ul>

        <h3>3Ô∏è‚É£ Entidades de Room</h3>
        <p>
            Las entidades son clases de datos que representan tablas en la base de datos SQLite. Cada propiedad
            de la clase se convierte en una columna de la tabla.
        </p>

        <h4>üìÑ UserEntity.kt</h4>
        <div class="box box-success">
            <pre><code>@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0L,

    val nombre: String,
    val correo: String,
    val telefono: String = "",
    val clave: String,
    val direccion: String = ""
)</code></pre>
        </div>

        <h4>üè∑Ô∏è Anotaciones de Entidades:</h4>
        <ul>
            <li><strong>@Entity:</strong> Marca la clase como una tabla de BD. <code>tableName</code> especifica el nombre</li>
            <li><strong>@PrimaryKey:</strong> Define la clave primaria. <code>autoGenerate = true</code> la hace autoincremental</li>
            <li><strong>data class:</strong> Clase de datos de Kotlin con equals(), hashCode(), toString() autom√°ticos</li>
            <li><strong>Valores por defecto:</strong> Permiten campos opcionales (telefono = "", direccion = "")</li>
        </ul>

        <div class="box box-warning">
            <h4>‚ö†Ô∏è Nota de Seguridad</h4>
            <p>
                En este proyecto educativo, la contrase√±a (<code>clave</code>) se almacena en texto plano.
                <strong>En producci√≥n, NUNCA hagas esto.</strong> Siempre usa hashing seguro como BCrypt, Argon2 o PBKDF2.
            </p>
        </div>

        <h4>üìÑ PedidoEntity.kt - Entidades Relacionadas</h4>
        <p>
            Este archivo contiene dos entidades relacionadas: <code>PedidoEntity</code> (cabecera del pedido) y
            <code>PedidoItemEntity</code> (items del pedido).
        </p>

        <div class="box box-info">
            <pre><code>@Entity(tableName = "pedidos")
data class PedidoEntity(
    @PrimaryKey
    val numeroPedido: String,     // Ej: "ALE00001"
    val nombreUsuario: String,
    val userId: Long,
    val subtotal: Int,
    val total: Int,
    val direccionEnvio: String,
    val metodoPago: String,
    val estado: String,
    val fechaCreacion: Long = System.currentTimeMillis(),
    // ... m√°s campos
)

@Entity(
    tableName = "pedido_items",
    primaryKeys = ["numeroPedido", "productoId", "talla", "color"]
)
data class PedidoItemEntity(
    val numeroPedido: String,
    val productoId: String,
    val productoNombre: String,
    val precio: Int,
    val cantidad: Int,
    val talla: String = "N/A",
    val color: String,
    // ... m√°s campos
)</code></pre>
        </div>

        <h4>üîó Clave Primaria Compuesta:</h4>
        <p>
            <code>PedidoItemEntity</code> usa una clave primaria compuesta de m√∫ltiples campos:
            <code>numeroPedido + productoId + talla + color</code>. Esto garantiza que no haya items duplicados
            con la misma configuraci√≥n en un pedido.
        </p>

        <h3>4Ô∏è‚É£ Repositorios - Patr√≥n Repository</h3>
        <p>
            Los repositorios son la capa de abstracci√≥n entre las fuentes de datos y el ViewModel. Coordinan
            operaciones entre m√∫ltiples fuentes (local y remota) y exponen una API limpia.
        </p>

        <h4>üìÑ UserRepository.kt</h4>
        <div class="box box-success">
            <pre><code>class UserRepository(private val userDao: UserDao) {

    suspend fun register(
        nombre: String, correo: String, telefono: String,
        clave: String, direccion: String
    ): Result&lt;Long&gt; {
        return withContext(Dispatchers.IO) {
            try {
                // Verificar si el correo ya existe
                if (userDao.getUserByEmail(correo) != null) {
                    return@withContext Result.failure(
                        Exception("El correo ya est√° registrado")
                    )
                }

                // Crear y guardar el nuevo usuario
                val newUser = UserEntity(
                    nombre = nombre,
                    correo = correo,
                    telefono = telefono,
                    clave = clave,
                    direccion = direccion
                )
                val userId = userDao.insert(newUser)
                Result.success(userId)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }

    suspend fun login(correo: String, clave: String): Result&lt;UserEntity&gt; {
        return withContext(Dispatchers.IO) {
            try {
                val user = userDao.getUserByEmail(correo)
                if (user == null) {
                    Result.failure(Exception("Usuario no encontrado"))
                } else if (user.clave != clave) {
                    Result.failure(Exception("Contrase√±a incorrecta"))
                } else {
                    Result.success(user)
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }

    // ... m√°s m√©todos
}</code></pre>
        </div>

        <h4>üîß Caracter√≠sticas del Repositorio:</h4>
        <ul>
            <li><strong>withContext(Dispatchers.IO):</strong> Ejecuta operaciones de BD en hilo de I/O</li>
            <li><strong>Result&lt;T&gt;:</strong> Tipo que encapsula √©xito o fallo de operaciones</li>
            <li><strong>Validaci√≥n de Negocio:</strong> Verifica correos duplicados antes de registrar</li>
            <li><strong>Manejo de Excepciones:</strong> Try-catch para capturar errores de BD</li>
            <li><strong>Abstracci√≥n:</strong> El ViewModel no sabe si los datos vienen de Room, API o cach√©</li>
        </ul>

        <h4>üìÑ PedidoRepository.kt</h4>
        <p>
            Este repositorio maneja operaciones m√°s complejas con m√∫ltiples tablas relacionadas (pedidos e items).
        </p>

        <div class="box box-info">
            <pre><code>class PedidoRepository(private val pedidoDao: PedidoDao) {

    suspend fun guardarPedido(
        pedido: PedidoCompleto,
        userId: Long
    ): Result&lt;String&gt; {
        return withContext(Dispatchers.IO) {
            try {
                // Convertir modelo de dominio a entidad
                val pedidoEntity = PedidoEntity(
                    numeroPedido = pedido.numeroPedido,
                    nombreUsuario = pedido.nombreUsuario,
                    userId = userId,
                    // ... mapeo de campos
                )

                // Convertir productos a items
                val items = pedido.productos.map { producto ->
                    PedidoItemEntity(
                        numeroPedido = pedido.numeroPedido,
                        productoId = producto.id,
                        // ... mapeo de campos
                    )
                }

                // Insertar en transacci√≥n impl√≠cita
                pedidoDao.insertPedido(pedidoEntity)
                pedidoDao.insertPedidoItems(items)

                Result.success(pedido.numeroPedido)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }

    fun obtenerPedidosUsuario(userId: Long): Flow&lt;List&lt;PedidoCompleto&gt;&gt; {
        return pedidoDao.getPedidosByUserId(userId).map { pedidos ->
            pedidos.map { pedidoEntity ->
                convertirAPedidoCompleto(pedidoEntity)
            }
        }
    }
}</code></pre>
        </div>

        <h4>üåä Flow para Datos Reactivos:</h4>
        <p>
            El m√©todo <code>obtenerPedidosUsuario</code> retorna un <code>Flow&lt;List&lt;PedidoCompleto&gt;&gt;</code>,
            que es un stream reactivo. Cuando los datos cambian en la BD, el Flow emite autom√°ticamente los nuevos valores,
            actualizando la UI sin necesidad de recargar manualmente.
        </p>

        <h3>5Ô∏è‚É£ Gesti√≥n de Sesi√≥n</h3>

        <h4>üìÑ SessionManager.kt - SharedPreferences</h4>
        <p>
            <code>SessionManager</code> usa <strong>SharedPreferences</strong> para almacenar datos de sesi√≥n del usuario
            de forma persistente y ligera.
        </p>

        <div class="box box-success">
            <pre><code>class SessionManager(context: Context) {

    private val prefs: SharedPreferences = context.getSharedPreferences(
        "user_session",
        Context.MODE_PRIVATE
    )

    companion object {
        private const val KEY_USER_ID = "user_id"
        private const val KEY_USER_NAME = "user_name"
        private const val KEY_IS_LOGGED_IN = "is_logged_in"
    }

    fun saveSession(user: UserEntity) {
        prefs.edit().apply {
            putLong(KEY_USER_ID, user.id)
            putString(KEY_USER_NAME, user.nombre)
            putString(KEY_USER_EMAIL, user.correo)
            putBoolean(KEY_IS_LOGGED_IN, true)
            apply()
        }
    }

    fun getCurrentUser(): UserEntity? {
        if (!isLoggedIn()) return null

        val id = prefs.getLong(KEY_USER_ID, 0L)
        val nombre = prefs.getString(KEY_USER_NAME, "") ?: ""
        // ... recuperar m√°s campos

        return if (id > 0) {
            UserEntity(id = id, nombre = nombre, ...)
        } else null
    }

    fun isLoggedIn(): Boolean {
        return prefs.getBoolean(KEY_IS_LOGGED_IN, false)
    }

    fun clearSession() {
        prefs.edit().clear().apply()
    }
}</code></pre>
        </div>

        <h4>üîë SharedPreferences vs DataStore:</h4>
        <table>
            <thead>
                <tr>
                    <th>Caracter√≠stica</th>
                    <th>SharedPreferences</th>
                    <th>DataStore</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>API</strong></td>
                    <td>S√≠ncrona</td>
                    <td>As√≠ncrona (Flow)</td>
                </tr>
                <tr>
                    <td><strong>Seguridad de Tipo</strong></td>
                    <td>No (usa Strings)</td>
                    <td>S√≠ (con Proto DataStore)</td>
                </tr>
                <tr>
                    <td><strong>Reactividad</strong></td>
                    <td>No</td>
                    <td>S√≠ (Flow)</td>
                </tr>
                <tr>
                    <td><strong>Uso Recomendado</strong></td>
                    <td>Datos simples, legado</td>
                    <td>Nuevos proyectos</td>
                </tr>
            </tbody>
        </table>

        <h4>üìÑ UserPreferences.kt - DataStore</h4>
        <p>
            Este archivo muestra el uso moderno de <strong>Jetpack DataStore</strong>, que es la evoluci√≥n de SharedPreferences.
        </p>

        <div class="box box-info">
            <pre><code>val Context.dataStore by preferencesDataStore("user_prefs")

class UserPreferences(private val context: Context) {

    private val isLoggedInKey = booleanPreferencesKey("is_logged_key")

    suspend fun setLoggedIn(value: Boolean) {
        context.dataStore.edit { prefs ->
            prefs[isLoggedInKey] = value
        }
    }

    val isLoggedIn: Flow&lt;Boolean&gt; = context.dataStore.data
        .map { prefs ->
            prefs[isLoggedInKey] ?: false
        }
}</code></pre>
        </div>

        <h4>üåä Ventajas de DataStore:</h4>
        <ul>
            <li><strong>API As√≠ncrona:</strong> No bloquea el hilo principal</li>
            <li><strong>Flow Reactivo:</strong> La UI se actualiza autom√°ticamente cuando cambian las preferencias</li>
            <li><strong>Type-Safe:</strong> Las keys est√°n tipadas (booleanPreferencesKey, intPreferencesKey, etc.)</li>
            <li><strong>Manejo de Excepciones:</strong> Mejor gesti√≥n de errores de I/O</li>
        </ul>

        <h3>6Ô∏è‚É£ Modelos de Datos</h3>
        <p>
            Los modelos de datos representan las estructuras de informaci√≥n que fluyen por la aplicaci√≥n.
            Hay diferentes tipos seg√∫n su prop√≥sito.
        </p>

        <h4>üéØ Tipos de Modelos:</h4>
        <ul>
            <li><strong>Entidades (Entity):</strong> Representan tablas de BD (UserEntity, PedidoEntity)</li>
            <li><strong>Modelos de Dominio:</strong> Objetos de negocio puros (Producto, ProductoCarrito)</li>
            <li><strong>DTOs (Data Transfer Objects):</strong> Para transferir datos con APIs (preparado para Retrofit)</li>
            <li><strong>UI Models:</strong> Optimizados para la vista (con propiedades computadas, formateo)</li>
        </ul>

        <h4>üìÑ Producto.kt - Modelo de Dominio</h4>
        <div class="box box-success">
            <pre><code>data class Producto(
    val id: String,
    val nombre: String,
    val descripcion: String,
    val precio: Int,
    val categoria: CategoriaProducto,
    val imagenResId: Int,
    val tallasDisponibles: List&lt;Talla&gt; = emptyList(),
    val coloresDisponibles: List&lt;ColorInfo&gt; = emptyList(),
    val stock: Int = 100,
    val calificacionPromedio: Float = 0f
) {
    fun requiereTalla(): Boolean = categoria.usaTallas()

    fun requiereColor(): Boolean =
        categoria != CategoriaProducto.ACCESORIOS ||
        coloresDisponibles.isNotEmpty()

    fun precioFormateado(): String = "$$precio"
}</code></pre>
        </div>

        <h4>üí° Ventajas de Propiedades Computadas:</h4>
        <p>
            Los m√©todos como <code>requiereTalla()</code> y <code>precioFormateado()</code> encapsulan l√≥gica de negocio
            en el modelo, evitando que esta l√≥gica se repita en m√∫ltiples lugares de la UI.
        </p>

        <h2>üîÑ Flujo de Datos en la Aplicaci√≥n</h2>
        <p>
            Veamos c√≥mo fluyen los datos desde el ViewModel hasta la base de datos y viceversa en un caso pr√°ctico.
        </p>

        <h3>üé¨ Escenario: Registro de Nuevo Usuario</h3>
        <div class="diagram">
            <div class="flow-step">1. UI (LoginScreen)</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">2. ViewModel (AuthViewModel)</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">3. Repository (UserRepository)</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">4. DAO (UserDao)</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">5. Room Database</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">6. SQLite</div>
        </div>

        <h4>üìù Descripci√≥n Paso a Paso:</h4>
        <ol>
            <li>
                <strong>UI (Composable):</strong> El usuario llena el formulario y presiona "Registrar".
                Se llama a <code>viewModel.register(nombre, correo, clave, ...)</code>
            </li>
            <li>
                <strong>ViewModel:</strong> Valida los datos de entrada (formato de email, longitud de contrase√±a).
                Si es v√°lido, llama a <code>repository.register(...)</code> en una corrutina
            </li>
            <li>
                <strong>Repository:</strong> Ejecuta <code>withContext(Dispatchers.IO)</code> para cambiar al hilo de I/O.
                Verifica si el correo ya existe consultando <code>userDao.getUserByEmail(correo)</code>
            </li>
            <li>
                <strong>DAO:</strong> Room traduce la consulta SQL a una operaci√≥n de BD real:
                <code>SELECT * FROM users WHERE correo = ? LIMIT 1</code>
            </li>
            <li>
                <strong>Room:</strong> Ejecuta la consulta en SQLite, deserializa el resultado a <code>UserEntity</code>
                (o null si no existe)
            </li>
            <li>
                <strong>Vuelta:</strong> Si no hay duplicado, el Repository llama a <code>userDao.insert(newUser)</code>,
                que inserta el registro y retorna el ID generado
            </li>
            <li>
                <strong>Resultado:</strong> El Repository retorna <code>Result.success(userId)</code>, el ViewModel
                actualiza el estado de UI a "√©xito", y la UI navega a la pantalla de inicio
            </li>
        </ol>

        <h3>üîç Escenario: Consultar Usuario por ID</h3>
        <div class="diagram">
            <div class="flow-step">1. ViewModel</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">2. Repository</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">3. DAO</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">4. Room Cache</div>
            <br><br>
            <div style="font-size: 1.2em; color: #667eea;">
                Si no est√° en cach√© ‚Üì
            </div>
            <br>
            <div class="flow-step">5. SQLite Query</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">6. Cache Update</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">7. Return to ViewModel</div>
        </div>

        <h4>‚ö° Optimizaciones de Room:</h4>
        <ul>
            <li><strong>Query Caching:</strong> Room cachea resultados de consultas en memoria</li>
            <li><strong>Invalidation Tracking:</strong> Detecta autom√°ticamente cuando los datos cambian</li>
            <li><strong>Flow Observability:</strong> Emite nuevos valores cuando la BD se actualiza</li>
            <li><strong>Transaction Support:</strong> Agrupa operaciones para garantizar consistencia</li>
        </ul>

        <h3>üõí Escenario Complejo: Guardar Pedido con Items</h3>
        <p>
            Este es un caso m√°s avanzado que involucra m√∫ltiples tablas relacionadas.
        </p>

        <div class="box box-warning">
            <h4>üìä Flujo de Guardado de Pedido:</h4>
            <pre><code>// 1. ViewModel solicita guardar pedido
viewModel.crearPedido(productos, metodoPago, direccion)

// 2. Repository prepara datos
suspend fun guardarPedido(pedido: PedidoCompleto, userId: Long) {
    withContext(Dispatchers.IO) {
        // 3. Mapeo de modelo de dominio a entidades
        val pedidoEntity = PedidoEntity(...)
        val items = pedido.productos.map { PedidoItemEntity(...) }

        // 4. Room ejecuta en transacci√≥n impl√≠cita
        pedidoDao.insertPedido(pedidoEntity)      // INSERT INTO pedidos...
        pedidoDao.insertPedidoItems(items)        // INSERT INTO pedido_items...

        // Si cualquier INSERT falla, se hace ROLLBACK autom√°tico
    }
}</code></pre>
        </div>

        <h4>üîí Transacciones en Room:</h4>
        <p>
            Aunque no lo vemos expl√≠citamente en el c√≥digo, Room maneja transacciones autom√°ticamente:
        </p>
        <ul>
            <li>Si usas <code>@Transaction</code> en el DAO, Room agrupa operaciones</li>
            <li>Si alguna operaci√≥n falla, se hace rollback de todas</li>
            <li>Garantiza consistencia: o se guarda todo, o nada</li>
        </ul>

        <h2>üéì Mejores Pr√°cticas Implementadas</h2>

        <div class="box box-success">
            <h3>‚úÖ Principios SOLID Aplicados</h3>
            <ul>
                <li>
                    <strong>Single Responsibility:</strong> Cada clase tiene una √∫nica responsabilidad
                    (UserDao solo accede a usuarios, UserRepository solo coordina datos de usuarios)
                </li>
                <li>
                    <strong>Open/Closed:</strong> Los repositorios pueden extenderse para agregar cach√©
                    sin modificar el c√≥digo existente
                </li>
                <li>
                    <strong>Liskov Substitution:</strong> Los DAOs pueden ser mockeados en tests
                </li>
                <li>
                    <strong>Interface Segregation:</strong> DAOs espec√≠ficos en lugar de un DAO gen√©rico gigante
                </li>
                <li>
                    <strong>Dependency Inversion:</strong> ViewModel depende de Repository (abstracci√≥n),
                    no de Room directamente (implementaci√≥n)
                </li>
            </ul>
        </div>

        <div class="box box-info">
            <h3>üîß Manejo de Concurrencia</h3>
            <ul>
                <li>
                    <strong>suspend functions:</strong> Todas las operaciones de BD son as√≠ncronas con corrutinas
                </li>
                <li>
                    <strong>Dispatchers.IO:</strong> Operaciones de BD ejecutadas en hilo de entrada/salida
                </li>
                <li>
                    <strong>Flow:</strong> Streams reactivos para observar cambios en tiempo real
                </li>
                <li>
                    <strong>Singleton Thread-Safe:</strong> AppDatabase usa @Volatile y synchronized
                </li>
            </ul>
        </div>

        <div class="box box-warning">
            <h3>‚ö†Ô∏è Consideraciones para Producci√≥n</h3>
            <ul>
                <li>
                    <strong>Seguridad de Contrase√±as:</strong> Implementar hashing con BCrypt o Argon2
                </li>
                <li>
                    <strong>Validaci√≥n de Datos:</strong> Agregar constraints en Room (@ColumnInfo, @Index)
                </li>
                <li>
                    <strong>Migraciones:</strong> Implementar migraciones apropiadas en lugar de fallbackToDestructiveMigration
                </li>
                <li>
                    <strong>Backup y Restauraci√≥n:</strong> Implementar exportaci√≥n de datos de usuario
                </li>
                <li>
                    <strong>Cifrado:</strong> Usar SQLCipher para encriptar la base de datos completa
                </li>
            </ul>
        </div>

        <h2>üìö Resumen y Conclusiones</h2>
        <p>
            La capa de datos de App AjiColor demuestra una implementaci√≥n s√≥lida de arquitectura MVVM con:
        </p>

        <div class="box box-success">
            <h4>‚ú® Fortalezas del Dise√±o:</h4>
            <ul>
                <li>‚úÖ <strong>Separaci√≥n clara de responsabilidades</strong> entre componentes</li>
                <li>‚úÖ <strong>Uso correcto de Room</strong> con DAOs, Entidades y relaciones</li>
                <li>‚úÖ <strong>Patr√≥n Repository</strong> que abstrae fuentes de datos</li>
                <li>‚úÖ <strong>Manejo as√≠ncrono</strong> con corrutinas y suspend functions</li>
                <li>‚úÖ <strong>Gesti√≥n de sesi√≥n</strong> con SharedPreferences y DataStore</li>
                <li>‚úÖ <strong>Modelos bien definidos</strong> con propiedades computadas</li>
                <li>‚úÖ <strong>Preparado para escalar</strong> a APIs remotas con Retrofit</li>
            </ul>
        </div>

        <div class="box box-info">
            <h4>üöÄ Siguientes Pasos Recomendados:</h4>
            <ol>
                <li>Implementar cach√© en el Repository con pol√≠tica de expiraci√≥n</li>
                <li>Agregar una fuente de datos remota (Retrofit + API REST)</li>
                <li>Implementar WorkManager para sincronizaci√≥n en background</li>
                <li>Agregar indices en Room para optimizar consultas frecuentes</li>
                <li>Implementar migraciones de BD para actualizaciones sin p√©rdida de datos</li>
                <li>Agregar tests unitarios para Repositories y DAOs</li>
            </ol>
        </div>

        <p style="text-align: center; margin-top: 40px; font-size: 1.1em; color: #667eea;">
            <strong>üì¶ La capa de datos es el coraz√≥n de la aplicaci√≥n: datos confiables = app confiable.</strong>
        </p>
    </div>
</body>
</html>
