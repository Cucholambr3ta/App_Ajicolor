        name.length < 2 -> "El nombre debe tener al menos 2 caracteres"
        // Evita nombres de una sola letra como "A" o "B"

        // REGLA 3: Solo letras y espacios
        !name.all { it.isLetter() || it.isWhitespace() }
            -> "El nombre solo puede contener letras"
        // it.isLetter()     : Verifica si es letra (A-Z, a-z, incluso con tildes)
        // it.isWhitespace() : Permite espacios para nombres compuestos
        // all { }           : TODOS los caracteres deben cumplir la condici√≥n

        else -> null
    }
}</code></pre>
        </div>

        <h4>üî¨ An√°lisis de Reglas de Negocio</h4>
        <div class="validation-rule">
            <strong>Regla de Solo Letras: all { it.isLetter() || it.isWhitespace() }</strong>
            <p>Itera cada car√°cter del string verificando que sea letra o espacio.</p>
            <div class="example error">‚ùå "Juan123" ‚Üí "El nombre solo puede contener letras"</div>
            <div class="example error">‚ùå "Mar√≠a@" ‚Üí "El nombre solo puede contener letras"</div>
            <div class="example error">‚ùå "Jos√©-Luis" ‚Üí "El nombre solo puede contener letras" (gui√≥n no permitido)</div>
            <div class="example success">‚úÖ "Juan" ‚Üí null (v√°lido)</div>
            <div class="example success">‚úÖ "Mar√≠a Jos√©" ‚Üí null (v√°lido, espacio permitido)</div>
            <div class="example success">‚úÖ "Jos√©" ‚Üí null (v√°lido, isLetter() soporta tildes)</div>
        </div>

        <h4>üí° Ventaja de isLetter() vs Regex</h4>
        <p>
            <code>isLetter()</code> es m√°s robusto que un regex simple <code>[A-Za-z]</code> porque:
        </p>
        <ul>
            <li>‚úÖ Reconoce caracteres Unicode (√°, √©, √≠, √≥, √∫, √±, √º, etc.)</li>
            <li>‚úÖ Soporta m√∫ltiples idiomas autom√°ticamente</li>
            <li>‚úÖ M√°s legible que regex complejo</li>
            <li>‚úÖ Rendimiento comparable o mejor</li>
        </ul>

        <h3>3Ô∏è‚É£ validatePhoneDigitsOnly() - Validaci√≥n de Tel√©fono</h3>
        <p>
            <strong>Responsabilidad √önica:</strong> Verificar que el tel√©fono solo contenga d√≠gitos y est√© en el rango v√°lido.
        </p>

        <div class="box box-success">
            <pre><code>fun validatePhoneDigitsOnly(phone: String): String? {
    return when {
        // REGLA 1: Campo obligatorio
        phone.isBlank() -> "El tel√©fono es obligatorio"

        // REGLA 2: Longitud m√≠nima (8 d√≠gitos)
        phone.length < 8 -> "El tel√©fono debe tener al menos 8 d√≠gitos"
        // Chile: tel√©fonos m√≥viles son 9 d√≠gitos (+569...)
        // Internacional: m√≠nimo razonable es 8

        // REGLA 3: Longitud m√°xima (15 d√≠gitos)
        phone.length > 15 -> "El tel√©fono no puede tener m√°s de 15 d√≠gitos"
        // ITU E.164: el m√°ximo internacional es 15 d√≠gitos

        // REGLA 4: Solo d√≠gitos num√©ricos
        !phone.all { it.isDigit() } -> "El tel√©fono solo puede contener n√∫meros"
        // No permite: espacios, guiones, par√©ntesis, signos +
        // Formato esperado: solo n√∫meros puros

        else -> null
    }
}</code></pre>
        </div>

        <h4>üî¨ Reglas de Negocio Aplicadas</h4>
        <div class="validation-rule">
            <strong>Formato Estricto: Solo D√≠gitos</strong>
            <p>Esta funci√≥n implementa validaci√≥n estricta sin formato visual.</p>
            <div class="example error">‚ùå "+56 9 1234 5678" ‚Üí "El tel√©fono solo puede contener n√∫meros"</div>
            <div class="example error">‚ùå "(02) 2345-6789" ‚Üí "El tel√©fono solo puede contener n√∫meros"</div>
            <div class="example error">‚ùå "912-345-678" ‚Üí "El tel√©fono solo puede contener n√∫meros"</div>
            <div class="example success">‚úÖ "912345678" ‚Üí null (v√°lido, 9 d√≠gitos)</div>
            <div class="example success">‚úÖ "223456789" ‚Üí null (v√°lido, 9 d√≠gitos)</div>
        </div>
<!DOCTYPE html>
        <h4>üåç Consideraci√≥n Internacional</h4>
        <p>
            El rango 8-15 d√≠gitos cubre la mayor√≠a de formatos telef√≥nicos mundiales seg√∫n el est√°ndar
            <strong>ITU-T E.164</strong>:
        </p>
        <ul>
            <li>Chile: 9 d√≠gitos (m√≥vil), 9 d√≠gitos (fijo con c√≥digo de √°rea)</li>
            <li>USA: 10 d√≠gitos</li>
            <li>M√©xico: 10 d√≠gitos</li>
            <li>Espa√±a: 9 d√≠gitos</li>
            <li>Internacional: hasta 15 d√≠gitos con c√≥digo de pa√≠s</li>
        </ul>

        <h3>4Ô∏è‚É£ validateStrongPassword() - Validaci√≥n de Contrase√±a</h3>
        <p>
            <strong>Responsabilidad √önica:</strong> Asegurar que la contrase√±a cumple con requisitos m√≠nimos de seguridad.
        </p>

        <div class="box box-warning">
            <pre><code>fun validateStrongPassword(password: String): String? {
    return when {
        // REGLA 1: Campo obligatorio
        password.isBlank() -> "La contrase√±a es obligatoria"

        // REGLA 2: Longitud m√≠nima absoluta (6 caracteres)
        password.length < 6 -> "La contrase√±a debe tener al menos 6 caracteres"
        // M√≠nimo aceptable, pero no recomendado

        // REGLA 3: Longitud recomendada (8 caracteres)
        password.length < 8 -> "Se recomienda al menos 8 caracteres para mayor seguridad"
        // Mensaje de advertencia, pero no bloquea
        // Contrase√±a de 6-7 caracteres: v√°lida pero con warning

        else -> null
    }
}</code></pre>
        </div>

        <h4>üîê An√°lisis de Seguridad</h4>
        <div class="validation-rule">
            <strong>Pol√≠tica de Contrase√±as: Enfoque Educativo</strong>
            <p>Esta funci√≥n implementa validaci√≥n b√°sica con mensajes educativos progresivos.</p>
            <div class="example error">‚ùå "12345" ‚Üí "La contrase√±a debe tener al menos 6 caracteres"</div>
            <div class="example error">‚ùå "Pass1" ‚Üí "La contrase√±a debe tener al menos 6 caracteres"</div>
            <div class="example success">‚ö†Ô∏è "Pass12" ‚Üí "Se recomienda al menos 8 caracteres..." (v√°lida con warning)</div>
            <div class="example success">‚ö†Ô∏è "Contra1" ‚Üí "Se recomienda al menos 8 caracteres..." (v√°lida con warning)</div>
            <div class="example success">‚úÖ "Password123" ‚Üí null (v√°lida, 11 caracteres)</div>
        </div>

        <h4>üí° Validaci√≥n Progresiva: M√≠nimo vs Recomendado</h4>
        <p>
            Esta funci√≥n implementa un patr√≥n inteligente de validaci√≥n en dos niveles:
        </p>
        <ul>
            <li><strong>Nivel 1 (Bloqueante):</strong> &lt; 6 caracteres ‚Üí Error duro, no permite continuar</li>
            <li><strong>Nivel 2 (Advertencia):</strong> 6-7 caracteres ‚Üí Mensaje educativo, permite continuar</li>
            <li><strong>Nivel 3 (√ìptimo):</strong> ‚â• 8 caracteres ‚Üí Sin mensaje, totalmente v√°lida</li>
        </ul>

        <div class="box box-info">
            <h4>üîí Mejoras para Producci√≥n</h4>
            <p>Para una aplicaci√≥n en producci√≥n, considera agregar validaciones adicionales:</p>
            <pre><code>fun validateProductionPassword(password: String): String? {
    return when {
        password.isBlank() -> "La contrase√±a es obligatoria"
        password.length < 8 -> "La contrase√±a debe tener al menos 8 caracteres"

        // Validaciones adicionales recomendadas:
        !password.any { it.isUpperCase() }
            -> "Debe contener al menos una may√∫scula"
        !password.any { it.isLowerCase() }
            -> "Debe contener al menos una min√∫scula"
        !password.any { it.isDigit() }
            -> "Debe contener al menos un n√∫mero"
        !password.any { !it.isLetterOrDigit() }
            -> "Debe contener al menos un car√°cter especial"
        password.length > 128
            -> "La contrase√±a no puede exceder 128 caracteres"

        else -> null
    }
}</code></pre>
        </div>

        <h3>5Ô∏è‚É£ validateConfirm() - Validaci√≥n de Confirmaci√≥n</h3>
        <p>
            <strong>Responsabilidad √önica:</strong> Verificar que la contrase√±a de confirmaci√≥n coincida con la original.
        </p>

        <div class="box box-success">
            <pre><code>fun validateConfirm(password: String, confirm: String): String? {
    // Esta funci√≥n recibe DOS par√°metros para comparar

    return when {
        // REGLA 1: Campo de confirmaci√≥n no vac√≠o
        confirm.isBlank() -> "Debes confirmar la contrase√±a"
        // Usuario dej√≥ el campo vac√≠o

        // REGLA 2: Ambas contrase√±as deben ser id√©nticas
        confirm != password -> "Las contrase√±as no coinciden"
        // Comparaci√≥n exacta, case-sensitive
        // "Password1" ‚â† "password1"

        else -> null
        // Confirmaci√≥n exitosa
    }
}</code></pre>
        </div>

        <h4>üîç L√≥gica de Comparaci√≥n</h4>
        <div class="validation-rule">
            <strong>Comparaci√≥n Case-Sensitive</strong>
            <p>El operador <code>!=</code> en Kotlin compara strings car√°cter por car√°cter, distinguiendo may√∫sculas.</p>
            <div class="example error">‚ùå Contrase√±a: "Pass123" / Confirmar: "pass123" ‚Üí No coinciden</div>
            <div class="example error">‚ùå Contrase√±a: "Pass123" / Confirmar: "Pass123 " ‚Üí No coinciden (espacio extra)</div>
            <div class="example success">‚úÖ Contrase√±a: "Pass123" / Confirmar: "Pass123" ‚Üí Coinciden</div>
        </div>

        <h4>üéØ Orden de Validaci√≥n Importante</h4>
        <p>
            El orden de las validaciones en <code>when</code> es crucial:
        </p>
        <ol>
            <li><strong>Primero:</strong> Verificar que confirm no est√© vac√≠o</li>
            <li><strong>Segundo:</strong> Comparar con password</li>
        </ol>
        <p>
            Si invirti√©ramos el orden, <code>"" != "Password1"</code> dar√≠a <code>true</code>
            mostrando "no coinciden" en lugar del mensaje m√°s espec√≠fico "debes confirmar".
        </p>

        <h3>6Ô∏è‚É£ validateDireccion() - Validaci√≥n de Direcci√≥n</h3>
        <p>
            <strong>Responsabilidad √önica:</strong> Asegurar que la direcci√≥n tenga una longitud m√≠nima razonable.
        </p>

        <div class="box box-info">
            <pre><code>fun validateDireccion(direccion: String): String? {
    return when {
        // REGLA 1: Campo obligatorio
        direccion.isBlank() -> "La direcci√≥n es obligatoria"

        // REGLA 2: Longitud m√≠nima (5 caracteres)
        direccion.length < 5 -> "La direcci√≥n debe tener al menos 5 caracteres"
        // Direcciones m√≠nimas v√°lidas:
        // "Av 12" (5 caracteres)
        // "Calle 1" (7 caracteres)

        else -> null
    }
}</code></pre>
        </div>

        <h4>üìç Validaci√≥n Flexible de Direcciones</h4>
        <p>
            Esta funci√≥n implementa validaci√≥n <strong>permisiva</strong> en lugar de restrictiva:
        </p>
        <ul>
            <li>‚úÖ Permite cualquier car√°cter (n√∫meros, letras, s√≠mbolos)</li>
            <li>‚úÖ No valida formato espec√≠fico (cada pa√≠s tiene convenciones diferentes)</li>
            <li>‚úÖ Solo verifica longitud m√≠nima razonable</li>
            <li>‚úÖ Asume que el usuario sabe su direcci√≥n correcta</li>
        </ul>

        <div class="validation-rule">
            <strong>Ejemplos de Direcciones V√°lidas</strong>
            <div class="example success">‚úÖ "Av. Libertador 1234, Depto 501" ‚Üí null (v√°lida)</div>
            <div class="example success">‚úÖ "Calle 123 #45-67" ‚Üí null (v√°lida)</div>
            <div class="example success">‚úÖ "Los √Ålamos 456" ‚Üí null (v√°lida)</div>
            <div class="example error">‚ùå "Av 1" ‚Üí "La direcci√≥n debe tener al menos 5 caracteres"</div>
        </div>

        <h2>üîó Relaci√≥n con ViewModel</h2>
        <p>
            Los ViewModels <strong>instancian y utilizan</strong> estas funciones de validaci√≥n para procesar
            la entrada del usuario de forma reactiva antes de enviarla a la capa de datos.
        </p>

        <h3>üé¨ Ejemplo Completo: AuthViewModel</h3>
        <div class="box box-success">
            <h4>üìÑ AuthViewModel.kt - Validaci√≥n en Acci√≥n</h4>
            <pre><code>class AuthViewModel(
    private val repository: UserRepository,
    private val sessionManager: SessionManager
) : ViewModel() {

    // Estado de UI del formulario de registro
    private val _register = MutableStateFlow(RegisterUiState())
    val register: StateFlow&lt;RegisterUiState&gt; = _register

    // ========================================
    // HANDLERS QUE LLAMAN A VALIDACIONES
    // ========================================

    // Handler cuando el usuario escribe su nombre
    fun onRegisterNameChange(value: String) {
        // 1. Actualizar el valor del campo
        // 2. LLAMAR A LA FUNCI√ìN DE VALIDACI√ìN
        // 3. Almacenar el resultado en el estado

        _register.update {
            it.copy(
                nombre = value,
                nombreError = validateNameLettersOnly(value)
                //           ‚Üë Funci√≥n de validaci√≥n invocada aqu√≠
            )
        }
        recomputeRegisterCanSubmit()  // Recalcular si puede enviar
    }

    // Handler cuando el usuario escribe su email
    fun onRegisterEmailChange(value: String) {
        _register.update {
            it.copy(
                correo = value,
                correoError = validateEmail(value)
                //           ‚Üë Validaci√≥n de email invocada
            )
        }
        recomputeRegisterCanSubmit()
    }

    // Handler cuando el usuario escribe su tel√©fono
    fun onRegisterPhoneChange(value: String) {
        _register.update {
            it.copy(
                telefono = value,
                telefonoError = validatePhoneDigitsOnly(value)
                //              ‚Üë Validaci√≥n de tel√©fono invocada
            )
        }
        recomputeRegisterCanSubmit()
    }

    // Handler cuando el usuario escribe su contrase√±a
    fun onRegisterPasswordChange(value: String) {
        val s = _register.value
        _register.update {
            it.copy(
                clave = value,
                claveError = validateStrongPassword(value),
                //          ‚Üë Validaci√≥n de contrase√±a
                confirmError = if (s.confirm.isNotBlank())
                    validateConfirm(value, s.confirm)
                else
                    null
                // ‚Üë Re-validar confirmaci√≥n si ya fue llenada
            )
        }
        recomputeRegisterCanSubmit()
    }

    // Handler cuando el usuario confirma la contrase√±a
    fun onRegisterConfirmChange(value: String) {
        val s = _register.value
        _register.update {
            it.copy(
                confirm = value,
                confirmError = validateConfirm(s.clave, value)
                //            ‚Üë Validar que coincida con contrase√±a
            )
        }
        recomputeRegisterCanSubmit()
    }

    // Handler cuando el usuario escribe su direcci√≥n
    fun onRegisterAddressChange(value: String) {
        _register.update {
            it.copy(
                direccion = value,
                direccionError = validateDireccion(value)
                //              ‚Üë Validaci√≥n de direcci√≥n
            )
        }
        recomputeRegisterCanSubmit()
    }

    // ========================================
    // VALIDACI√ìN GLOBAL DEL FORMULARIO
    // ========================================

    private fun recomputeRegisterCanSubmit() {
        val s = _register.value

        // El bot√≥n de enviar se habilita solo si:
        // 1. Todos los campos tienen contenido
        // 2. NING√öN campo tiene error de validaci√≥n

        val canSubmit = s.nombre.isNotBlank() &&
                        s.correo.isNotBlank() &&
                        s.telefono.isNotBlank() &&
                        s.clave.isNotBlank() &&
                        s.confirm.isNotBlank() &&
                        s.direccion.isNotBlank() &&
                        s.nombreError == null &&      // ‚Üê Sin error
                        s.correoError == null &&      // ‚Üê Sin error
                        s.telefonoError == null &&    // ‚Üê Sin error
                        s.claveError == null &&       // ‚Üê Sin error
                        s.confirmError == null &&     // ‚Üê Sin error
                        s.direccionError == null      // ‚Üê Sin error

        _register.update { it.copy(canSubmit = canSubmit) }
    }

    // ========================================
    // ENV√çO DEL FORMULARIO
    // ========================================

    fun submitRegister() {
        val s = _register.value
        if (!s.canSubmit || s.isSubmitting) return

        // Si llegamos aqu√≠, sabemos que:
        // - Todos los campos son v√°lidos
        // - No hay errores de validaci√≥n
        // - El usuario puede proceder

        viewModelScope.launch {
            _register.update {
                it.copy(isSubmitting = true, errorMsg = null)
            }

            // Llamar al repositorio para registrar
            val result = repository.register(
                nombre = s.nombre.trim(),
                correo = s.correo.trim(),
                telefono = s.telefono.trim(),
                clave = s.clave,
                direccion = s.direccion.trim()
            )

            _register.update {
                if (result.isSuccess) {
                    it.copy(isSubmitting = false, success = true)
                } else {
                    it.copy(
                        isSubmitting = false,
                        errorMsg = result.exceptionOrNull()?.message
                    )
                }
            }
        }
    }
}</code></pre>
        </div>

        <h3>üîÑ Flujo Completo de Validaci√≥n</h3>
        <div class="diagram">
            <div class="flow-step">1. Usuario Escribe</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">2. onChange Handler</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">3. Validation Function</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">4. Update State (error/null)</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">5. Recomponer UI</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">6. Mostrar Error/Habilitar Bot√≥n</div>
        </div>

        <h4>üìù Ejemplo Paso a Paso</h4>
        <ol>
            <li>
                <strong>Usuario escribe:</strong> "juan@" en el campo de email
            </li>
            <li>
                <strong>TextField llama:</strong> <code>onRegisterEmailChange("juan@")</code>
            </li>
            <li>
                <strong>ViewModel ejecuta:</strong> <code>validateEmail("juan@")</code>
            </li>
            <li>
                <strong>Funci√≥n retorna:</strong> <code>"Formato de correo inv√°lido"</code>
            </li>
            <li>
                <strong>Estado actualizado:</strong> <code>correoError = "Formato de correo inv√°lido"</code>
            </li>
            <li>
                <strong>UI recompone:</strong> TextField muestra error en rojo
            </li>
            <li>
                <strong>Bot√≥n deshabilitado:</strong> <code>canSubmit = false</code> porque hay error
            </li>
        </ol>

        <h3>üé® En la UI (Composable)</h3>
        <div class="box box-info">
            <pre><code>@Composable
fun RegistroScreen(
    navController: NavController,
    viewModel: AuthViewModel
) {
    val state by viewModel.register.collectAsState()

    Column {
        // Campo de Email con validaci√≥n visual
        OutlinedTextField(
            value = state.correo,
            onValueChange = viewModel::onRegisterEmailChange,
            //              ‚Üë Llama al handler que valida
            label = { Text("Email") },
            isError = state.correoError != null,
            //        ‚Üë Muestra error visual si no es null
            supportingText = {
                state.correoError?.let {
                    Text(it, color = MaterialTheme.colorScheme.error)
                }
                // ‚Üë Muestra el mensaje de error debajo del campo
            }
        )

        // ... m√°s campos con misma estructura

        // Bot√≥n de registro
        Button(
            onClick = { viewModel.submitRegister() },
            enabled = state.canSubmit && !state.isSubmitting
            //        ‚Üë Solo habilitado si todas las validaciones pasan
        ) {
            if (state.isSubmitting) {
                CircularProgressIndicator(modifier = Modifier.size(20.dp))
            } else {
                Text("Registrarse")
            }
        }
    }
}</code></pre>
        </div>

        <h2>‚úÖ Ventajas de este Enfoque</h2>

        <div class="box box-success">
            <h3>üéØ Beneficios T√©cnicos</h3>
            <ul>
                <li><strong>Funciones Puras:</strong> Sin side effects, f√°ciles de testear</li>
                <li><strong>Reutilizaci√≥n:</strong> Misma validaci√≥n en Login, Registro, Perfil</li>
                <li><strong>Single Source of Truth:</strong> Cambiar regla en un solo lugar</li>
                <li><strong>Separaci√≥n de Responsabilidades:</strong> L√≥gica de negocio independiente</li>
                <li><strong>Testeable:</strong> Tests unitarios sin mocks de Android</li>
            </ul>
        </div>

        <div class="box box-info">
            <h3>üß™ Ejemplo de Test Unitario</h3>
            <pre><code>@Test
fun `email vac√≠o devuelve error obligatorio`() {
    val result = validateEmail("")
    assertEquals("El correo es obligatorio", result)
}

@Test
fun `email sin arroba devuelve error inv√°lido`() {
    val result = validateEmail("usuariogmail.com")
    assertEquals("Correo inv√°lido", result)
}

@Test
fun `email v√°lido devuelve null`() {
    val result = validateEmail("usuario@gmail.com")
    assertNull(result)
}

@Test
fun `nombre con n√∫meros devuelve error`() {
    val result = validateNameLettersOnly("Juan123")
    assertEquals("El nombre solo puede contener letras", result)
}

@Test
fun `tel√©fono con menos de 8 d√≠gitos devuelve error`() {
    val result = validatePhoneDigitsOnly("1234567")
    assertEquals("El tel√©fono debe tener al menos 8 d√≠gitos", result)
}</code></pre>
        </div>

        <h2>üöÄ Mejoras Futuras Sugeridas</h2>

        <div class="box box-warning">
            <h3>üìà Evoluci√≥n de la Capa de Validaci√≥n</h3>
            <ol>
                <li>
                    <strong>Extraer a Casos de Uso (Use Cases):</strong>
                    <pre><code>class ValidateEmailUseCase {
    operator fun invoke(email: String): ValidationResult {
        return when {
            email.isBlank() -> ValidationResult.Error("El correo es obligatorio")
            !email.matches(emailRegex) -> ValidationResult.Error("Formato inv√°lido")
            else -> ValidationResult.Success
        }
    }
}

sealed class ValidationResult {
    object Success : ValidationResult()
    data class Error(val message: String) : ValidationResult()
}</code></pre>
                </li>
                <li>
                    <strong>Agregar Validaciones As√≠ncronas:</strong>
                    <pre><code>class ValidateEmailAvailabilityUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(email: String): ValidationResult {
        val exists = repository.emailExists(email)
        return if (exists) {
            ValidationResult.Error("El correo ya est√° registrado")
        } else {
            ValidationResult.Success
        }
    }
}</code></pre>
                </li>
                <li>
                    <strong>Internacionalizaci√≥n (i18n):</strong>
                    <pre><code>fun validateEmail(email: String, strings: StringResources): String? {
    return when {
        email.isBlank() -> strings.emailRequired
        !email.contains("@") -> strings.emailInvalid
        else -> null
    }
}</code></pre>
                </li>
            </ol>
        </div>

        <h2>üìö Resumen</h2>
        <p>
            La capa de validaci√≥n de App AjiColor implementa l√≥gica de negocio pura con:
        </p>

        <div class="box box-success">
            <ul>
                <li>‚úÖ <strong>6 funciones de validaci√≥n</strong> especializadas y reutilizables</li>
                <li>‚úÖ <strong>Funciones puras</strong> sin dependencias de Android</li>
                <li>‚úÖ <strong>Validaci√≥n reactiva</strong> en tiempo real desde ViewModels</li>
                <li>‚úÖ <strong>Mensajes de error claros</strong> y espec√≠ficos para el usuario</li>
                <li>‚úÖ <strong>Separaci√≥n de responsabilidades</strong> clara</li>
                <li>‚úÖ <strong>F√°cilmente testeable</strong> con tests unitarios</li>
                <li>‚úÖ <strong>Escalable</strong> para agregar m√°s validaciones</li>
            </ul>
        </div>

        <p style="text-align: center; margin-top: 40px; font-size: 1.1em; color: #667eea;">
            <strong>‚úÖ Validaci√≥n = Funciones Puras + L√≥gica de Negocio + Experiencia de Usuario</strong>
        </p>
    </div>
</body>
</html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lisis de la L√≥gica de Dominio y Validaci√≥n - App AjiColor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 40px;
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 30px;
            border-bottom: 4px solid #764ba2;
            padding-bottom: 15px;
            text-align: center;
        }

        h2 {
            color: #764ba2;
            font-size: 2em;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-left: 10px;
            border-left: 5px solid #667eea;
        }

        h3 {
            color: #5a67d8;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
            background: linear-gradient(to right, #f0f4ff, transparent);
            padding: 10px 15px;
            border-radius: 5px;
        }

        h4 {
            color: #4c51bf;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
            color: #444;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
            color: #555;
        }

        code {
            background: #f7fafc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e53e3e;
            font-size: 0.9em;
        }

        pre {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #667eea;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        pre code {
            background: transparent;
            color: #e2e8f0;
            padding: 0;
            font-size: 0.95em;
        }

        .highlight {
            background: linear-gradient(120deg, #ffd60a 0%, #ffd60a 100%);
            background-repeat: no-repeat;
            background-size: 100% 30%;
            background-position: 0 90%;
            padding: 2px 0;
        }

        .box {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .box-info {
            background: #ebf8ff;
            border-color: #3182ce;
        }

        .box-warning {
            background: #fffaf0;
            border-color: #ed8936;
        }

        .box-success {
            background: #f0fff4;
            border-color: #38a169;
        }

        .diagram {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .flow-step {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .arrow {
            display: inline-block;
            color: #667eea;
            font-size: 2em;
            margin: 0 10px;
            font-weight: bold;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: bold;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        tr:hover {
            background: #f7fafc;
        }

        .folder-tree {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            line-height: 1.8;
        }

        .folder {
            color: #ffd60a;
            font-weight: bold;
        }

        .file {
            color: #68d391;
        }

        .annotation {
            color: #9f7aea;
            font-style: italic;
        }

        .validation-rule {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }

        .validation-rule strong {
            color: #667eea;
            display: block;
            margin-bottom: 8px;
        }

        .example {
            background: #f0fff4;
            border: 1px solid #38a169;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .example.error {
            background: #fff5f5;
            border-color: #e53e3e;
            color: #e53e3e;
        }

        .example.success {
            background: #f0fff4;
            border-color: #38a169;
            color: #38a169;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚úÖ An√°lisis de la L√≥gica de Dominio y Validaci√≥n (/domain/validation)</h1>

        <h2>üéØ Prop√≥sito de la Capa de Validaci√≥n</h2>
        <p>
            La carpeta <code>/domain/validation</code> contiene la <span class="highlight">l√≥gica de negocio pura</span>
            relacionada con la validaci√≥n de datos del usuario. Esta capa se abstrae completamente de la UI y los ViewModels,
            siguiendo el principio de <strong>Separaci√≥n de Responsabilidades (Separation of Concerns)</strong> de Clean Architecture.
        </p>

        <div class="box box-info">
            <h4>üîë Principios Fundamentales</h4>
            <ul>
                <li><strong>L√≥gica de Negocio Pura:</strong> Sin dependencias de Android Framework</li>
                <li><strong>Reutilizaci√≥n:</strong> Las mismas reglas aplicables en m√∫ltiples ViewModels</li>
                <li><strong>Testeable:</strong> Funciones puras f√°ciles de probar unitariamente</li>
                <li><strong>Mantenible:</strong> Cambios en reglas de validaci√≥n centralizados en un solo lugar</li>
                <li><strong>Single Responsibility:</strong> Cada funci√≥n valida UN solo aspecto</li>
            </ul>
        </div>

        <h3>üèóÔ∏è Arquitectura de Validaci√≥n</h3>
        <div class="diagram">
            <div class="flow-step">UI Input</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">ViewModel</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Validation Functions</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Result (null or error)</div>
            <span class="arrow">‚Üí</span>
            <div class="flow-step">Update UI State</div>
        </div>

        <h3>üé® ¬øPor qu√© separar la validaci√≥n?</h3>
        <table>
            <thead>
                <tr>
                    <th>Sin Separaci√≥n</th>
                    <th>Con Capa de Validaci√≥n</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>‚ùå L√≥gica mezclada en ViewModel</td>
                    <td>‚úÖ Funciones puras reutilizables</td>
                </tr>
                <tr>
                    <td>‚ùå C√≥digo duplicado en m√∫ltiples pantallas</td>
                    <td>‚úÖ Una √∫nica fuente de verdad</td>
                </tr>
                <tr>
                    <td>‚ùå Dif√≠cil de testear (requiere mocks)</td>
                    <td>‚úÖ Tests unitarios simples</td>
                </tr>
                <tr>
                    <td>‚ùå Cambios requieren tocar m√∫ltiples archivos</td>
                    <td>‚úÖ Cambios centralizados</td>
                </tr>
                <tr>
                    <td>‚ùå Mezcla responsabilidades</td>
                    <td>‚úÖ Separaci√≥n clara de responsabilidades</td>
                </tr>
            </tbody>
        </table>

        <h2>üìÇ Estructura de /domain/validation</h2>
        <div class="folder-tree">
üìÅ domain/
‚îî‚îÄ‚îÄ üìÅ <span class="folder">validation/</span>
    ‚îî‚îÄ‚îÄ üìÑ <span class="file">ValidationFunctions.kt</span>    <span class="annotation">// Funciones puras de validaci√≥n</span>
        </div>

        <h2>üîç An√°lisis Detallado de Funciones de Validaci√≥n</h2>

        <h3>1Ô∏è‚É£ validateEmail() - Validaci√≥n de Correo Electr√≥nico</h3>
        <p>
            <strong>Responsabilidad √önica:</strong> Verificar que un correo electr√≥nico cumpla con el formato est√°ndar RFC 5322.
        </p>

        <div class="box box-success">
            <h4>üìù C√≥digo Completo con Explicaci√≥n L√≠nea por L√≠nea</h4>
            <pre><code>fun validateEmail(email: String): String? {
    // Entrada: String con el correo a validar
    // Salida: String? (null si es v√°lido, mensaje de error si es inv√°lido)

    return when {
        // REGLA 1: Campo obligatorio
        email.isBlank() -> "El correo es obligatorio"
        // Verifica si el string est√° vac√≠o o solo tiene espacios

        // REGLA 2: Debe contener "@"
        !email.contains("@") -> "Correo inv√°lido"
        // Validaci√≥n b√°sica: todo email debe tener arroba

        // REGLA 3: Formato RFC completo con Regex
        !email.matches(Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"))
            -> "Formato de correo inv√°lido"
        // ^[A-Za-z0-9+_.-]+  : Parte local (antes del @)
        // @                   : Separador obligatorio
        // [A-Za-z0-9.-]+      : Dominio
        // \\.                 : Punto literal
        // [A-Za-z]{2,}$       : TLD (m√≠nimo 2 letras, ej: .cl, .com)

        // REGLA 4: Todas las validaciones pasadas
        else -> null
        // null significa que el email es v√°lido
    }
}</code></pre>
        </div>

        <h4>üî¨ An√°lisis de Reglas de Negocio</h4>
        <div class="validation-rule">
            <strong>Regla 1: Campo Obligatorio</strong>
            <p>No permite emails vac√≠os ni strings que solo contengan espacios en blanco.</p>
            <div class="example error">‚ùå "" (vac√≠o) ‚Üí "El correo es obligatorio"</div>
            <div class="example error">‚ùå "   " (espacios) ‚Üí "El correo es obligatorio"</div>
        </div>

        <div class="validation-rule">
            <strong>Regla 2: Presencia de Arroba (@)</strong>
            <p>Validaci√≥n r√°pida que evita procesamiento de regex en casos obvios.</p>
            <div class="example error">‚ùå "usuariogmail.com" ‚Üí "Correo inv√°lido"</div>
            <div class="example error">‚ùå "usuario" ‚Üí "Correo inv√°lido"</div>
        </div>

        <div class="validation-rule">
            <strong>Regla 3: Formato Completo (Regex RFC 5322 Simplificado)</strong>
            <p>Valida estructura completa: parte local + @ + dominio + TLD</p>
            <div class="example error">‚ùå "usuario@" ‚Üí "Formato de correo inv√°lido"</div>
            <div class="example error">‚ùå "@gmail.com" ‚Üí "Formato de correo inv√°lido"</div>
            <div class="example error">‚ùå "usuario@gmail" ‚Üí "Formato de correo inv√°lido"</div>
            <div class="example error">‚ùå "usuario@gmail.c" ‚Üí "Formato de correo inv√°lido"</div>
            <div class="example success">‚úÖ "usuario@gmail.com" ‚Üí null (v√°lido)</div>
            <div class="example success">‚úÖ "juan.perez+alias@empresa.cl" ‚Üí null (v√°lido)</div>
        </div>

        <h4>üìä Entrada y Salida</h4>
        <table>
            <thead>
                <tr>
                    <th>Aspecto</th>
                    <th>Descripci√≥n</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Entrada</strong></td>
                    <td><code>email: String</code> - Correo electr√≥nico a validar</td>
                </tr>
                <tr>
                    <td><strong>Salida</strong></td>
                    <td><code>String?</code> - null si v√°lido, mensaje de error si inv√°lido</td>
                </tr>
                <tr>
                    <td><strong>Tipo de Validaci√≥n</strong></td>
                    <td>Formato, presencia, estructura</td>
                </tr>
                <tr>
                    <td><strong>Complejidad</strong></td>
                    <td>O(n) - Regex lineal con el tama√±o del string</td>
                </tr>
            </tbody>
        </table>

        <h3>2Ô∏è‚É£ validateNameLettersOnly() - Validaci√≥n de Nombre</h3>
        <p>
            <strong>Responsabilidad √önica:</strong> Asegurar que el nombre solo contenga letras y espacios, con longitud m√≠nima.
        </p>

        <div class="box box-info">
            <pre><code>fun validateNameLettersOnly(name: String): String? {
    return when {
        // REGLA 1: Campo obligatorio
        name.isBlank() -> "El nombre es obligatorio"

        // REGLA 2: Longitud m√≠nima (2 caracteres)

